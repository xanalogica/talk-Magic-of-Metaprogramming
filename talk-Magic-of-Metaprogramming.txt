.. include:: <s5defs.txt>

==============================
 The Magic of Metaprogramming
==============================

.. class:: sidebox boxed incremental

   .. image:: graphics/coordinator-of-pgms.jpg

:Author: Jeff Rush <jeff@taupro.com>
:Copyright: 2011 Tau Productions Inc.
:License: Creative Commons Attribution-ShareAlike 3.0
:Date: August 27, 2011
:Duration: 45-minutes
:Difficulty: Advanced
:Keywords: metaprogramming, data structures, language, techniques

Learn the magic of writing Python code that monitors, alters and reacts to
module imports, changes to variables, calls to functions and invocations of
the builtins.  Learn out to slide a class underneath a module to intercept
reads/writes, place automatic type checking over your object attributes and
use stack peeking to make selected attributes private to their owning class.
We'll cover import hacking, metaclasses, descriptors and decorators and how
they work internally.

.. |bullet| unicode:: U+02022
.. footer:: Kiwi PyCon 2011 |bullet| Wellington

.. role:: altway
   :class: altway

Who Am I?
=========

.. container:: slide-display

   .. class:: incremental

      + one who (really) loves to program (and teach)
      + programming since 1971, in Python since 1996
      + organizer (PyCon US, PSF, ZF, DFW Pythoneers)
      + self-employed developer and trainer
      + author of many screencasts on showmedo.com

What is Metaprogramming?
========================

.. container:: slide-display

   .. class:: incremental

      `the writing of programming code that`
      `writes, analyzes or adjusts other code,`
      `using that other code's structure`
      `as its data.`

      ..

      + two general forms: manipulation from

        .. class:: incremental

           + inside

             + stays in production
             + reduces developer workload

           + outside

             + for debugging, testing

Tools At Our Disposal
=====================

.. container:: slide-display

   .. class:: incremental

      + makes use of

        .. class:: incremental

           + metaclasses
           + decorators (class and function)
           + attribute lookups special functions
           + descriptors (and properties)

      ..

      + I cover only Python 2.x, new-style classes.

Orientation Diagram: What is Metaprogramming
============================================

.. container:: slide-display animation

   .. class:: incremental

      .. container:: handout

         seq-mp-code-data-X   (walk 'Code' and 'Data' blocks onto screen-center)
         seq-mp-datacomp-X    (add dnarrow and 'Data Computation' box from left)
         seq-mp-uievents-X    (add uparrow and 'UI Events' box from right)
         seq-mp-convpgm-X     (slide shade over system and add label along bottom)
         seq-mp-metacode-X    (slide entire arrangement down, and walk 'Metacode' box onto screen-center)
         seq-mp-plumbing-X    (add dnarrow and 'Plumbing Adjustments' box from left)
         seq-mp-addattrs-X    (walk out "add/adjust attributes")
         seq-mp-register-X    (walk out "register elements")
         seq-mp-tagstuff-X    (walk out "tag elements")
         seq-mp-codeevents-X  (add uparrow and "Code Events")
         seq-mp-modimport-X   (walk out "import of a module")
         seq-mp-classdef-X    (walk out "definition of a class/function")
         seq-mp-dotted-rdwr-X (walk out "write to a dotted name")
         seq-mp-callnret-X    (walk out "call and return")
         seq-mp-metapgm-X     (slide shade over upper system and add label along top)

      .. image:: graphics/mp-code-data.gif
      .. image:: graphics/mp-datacomp.gif
      .. image:: graphics/mp-uievents.gif
      .. image:: graphics/mp-convpgm.gif
      .. image:: graphics/mp-metacode.gif
      .. image:: graphics/mp-plumbing.gif
      .. image:: graphics/mp-addattrs.gif
      .. image:: graphics/mp-register.gif
      .. image:: graphics/mp-tagstuff.gif
      .. image:: graphics/mp-codeevents.gif
      .. image:: graphics/mp-modimport.gif
      .. image:: graphics/mp-classdef.gif
      .. image:: graphics/mp-dotted-rdwr.gif
      .. image:: graphics/mp-callnret.gif
      .. image:: graphics/mp-metapgm.gif

   .. class:: handout

      + Diagram - data <-> code <-> metacode, app-events versus code-events

      + Runtime Events

        + class initialization
        + function definition
        + module import
        + modification of a dotted name
        + retrieval of a dotted name
        + calling something

        ..

        + can be specific to a particular module or class

        + execution events
          1) initialization of a class definition
             - read class attrs and act on them
             - add/adjust methods
               - descriptors to control access to instance attrs
               - wrappers to hear about calls to both instance and class methods
                 - add a new instance to a registry
             - add the new class to a registry

Sample Problem #1: Subclassing an Embedded Class
================================================

.. container:: slide-display

   .. class:: sidebox boxed incremental

      | class Request(object):
      |     ...
      | class HTTPServer(object):
      |     def handle_request(self, ...):
      |         req = Request(...)
      |     ...

   .. class:: incremental

      + Objective

        + subclass a class deep inside a module

      ..

      + Challenges: They didn't

        .. class:: incremental

           + use a public factory
           + import from elsewhere
           + take the class as a parameter

      ..

      + A Metaprogramming Solution:

        .. class:: incremental

           + catch a specific import, so we can
           + redefine "Request" to be a subclass

A Solution to #1: Post-Import Hooking
=====================================

.. container:: slide-display

   *After import, rearrange content of module before others use it.*

   .. class:: incremental

      | old__import__ = sys.modules['__builtin__']
      | sys.modules['__builtin__'].__import__ = self.__import__

      | def __import__(modname):
      |
      |     m = old__import__(modname)
      |
      |     if modname == 'webserver':
      |         `frame = sys._getframe(1)`
      |         `importing_file = inspect.getsourcefile(frame) or inspect.getfile(frame)`
      |         `if fnmatch.fnmatch(importing_file, "*startup*"):`
      |             rearrange(m)
      |     return m

A Solution to #1 (Packaged Up)
==============================

.. container:: slide-display

   *After import, rearrange content of module before others use it.*

   .. class:: sidebox boxed

      | class Request(object):
      |     ...
      | class HTTPServer(object):
      |     def handle_request(self, ...):
      |         req = Request(...)
      |     ...

   .. class:: incremental

      | from tau.metaservices import MetaServices

      | def adjust(mod):
      |     from replacements import Request
      |     mod.Request = Request
      |

      | ms = MetaServices()
      | ms.call_after_import_of(
      |     'webserver', adjust `, from_filepatt='*startup*'`)

      | from webapp import main
      | main()

Alternate Solution: Pre-Import Hooking
======================================

.. container:: slide-display

   *Just before import, slip in a subclassed module object.*

   .. class:: incremental

      | def __import__(modname):
      |
      |     if modname == 'webserver':
      |
      |         `class SubclassingHooks(ihooks.Hooks):`
      |             `def new_module(self, modname):`
      |                 `return YourModuleFixer(modname)   # <--- your class`
      |
      |         `loader = ihooks.FancyModuleLoader(hooks=SubclassingHooks())`
      |         `importer = ihooks.ModuleImporter(loader)`
      |     else:
      |         importer = old__import__
      |
      |     return importer(modname)

What Does a Subclassed Module Look Like?
========================================

.. container:: slide-display

   .. class:: incremental

      | from types import ModuleType
      | class ModuleWatcher(ModuleType):
      |
      |     def __init__(self, modname):
      |         Moduletype.__init__(self, modname)
      |
      |     def __getattribute__(self, attrname):
      |
      |         `modname = ModuleType.__getattribute__(self, '__name__')  # self.__name__`
      |         `print "__getattribute__ fetching %r of %r" % (attrname, self)`
      |
      |         `if modname == 'webserver' and attrname == 'Request':`
      |             `from replacements import Request`
      |             `return Request`
      |
      |         return ModuleType.__getattribute__(self, attrname)

Some Benefits of Subclassing Modules
====================================

.. container:: slide-display

   .. class:: incremental

      + intercept attribute reads/writes
      + prevent/log writes
      + log timestamps and caller locations
      + return different values to different callers

      ..

      + tip: you can put non-module stuff on sys.path

      >>> import sys
      >>> sys.modules['TheAnswer'] = 42
      >>> import TheAnswer
      >>> TheAnswer
      42

Lull After Import Hooking, Before Metaclasses
=============================================

.. container:: slide-display center

   .. image:: graphics/after-imports-breathing.jpg

   + (pause - take a deep breath...)

Orientation Diagram: Instances, Classes and Metaclasses
=======================================================

.. container:: slide-display animation

   .. class:: incremental

      .. container:: handout

         seq-hc-justbits-X
            title 'a fable (literary licence) of objects'
            in the beginning there was just 1's and 0's  (show a heap of them)

         seq-hc-funcs-vars-X
            they separated into code (functions) and data (variables); a function could
            reach out and change any variable and each variable had to have a unique
            name.  It was unclear which vars went with which functions.

         seq-hc-vargroups-X
            Vars got grouped together, int C structs or Pascal records.  But functions
            were still separate.

         seq-hc-groupings-X
            Functions became got added into the var groupings.

         seq-hc-group-ctor-X
            There was a 'constructor' function that created each var grouping, according
            to what was needed each time.

         seq-hc-protos-X
            Then instead of rebuilding, a var group was used as a 'prototype object' to stamp out
            copies of itself.  The copier was the constructor of copies, named __call__.

         seq-hc-groupsplit-X
            Lots of duplicated code, excess copying of things that are common.  Decided to
            make two var groups, one for the shared stuff and one constructed for each
            instance.  The shared stuff represented a 'class of similar objects', shortened
            to 'class'.  No inheritance yet.

         seq-hc-groups-grow-X
            But the stuff shared among instances grew in size, and there was common code
            btw classes,

         seq-hc-delegating-X
            so inheritance was born; factoring vertically.

         seq-hc-new-axis-X
            One-dimension of creation just got a second dimension of delegation/inheritance.

         seq-hc-multi-inherit-X
            Assembly of classes was still complex, wanted more freedom to mix-and-match.
            Multiple inheritance was born.

         seq-hc-metaclass-X
            All these classes had code to create them, buried in the interpreter.  The
            code got exposed into a class-like object called metaclasses.

         seq-hc-meta-as-ctor-X
            Since classes
            are objects, their constructor, named __call__ resides in the metaclass.  One
            metaclass created all classes, since they were all alike in behavior.  Just
            containers of methods mostly.

         seq-hc-submetas-X
            But then the metaclass is subclassable, making it possible to create new kinds
            of classes.

      .. image:: graphics/hc-justbits.gif
      .. image:: graphics/hc-funcs-vars.gif
      .. image:: graphics/hc-vargroups.gif
      .. image:: graphics/hc-groupings.gif
      .. image:: graphics/hc-group-ctor.gif
      .. image:: graphics/hc-protos.gif
      .. image:: graphics/hc-groupsplit.gif
      .. image:: graphics/hc-groups-grow.gif
      .. image:: graphics/hc-delegating.gif
      .. image:: graphics/hc-new-axis.gif
      .. image:: graphics/hc-multi-inherit.gif
      .. image:: graphics/hc-metaclass.gif
      .. image:: graphics/hc-meta-as-ctor.gif
      .. image:: graphics/hc-submetas.gif

Facts About Metaclasses
=======================

.. container:: slide-display

   .. class:: incremental

      + a metaclass implements a "kind of class"
      + almost always you only need one kind
      + defining your own metaclass creates a "new kind"
      + smarter classes, more than "containers of methods"

      ..

      + new kinds are useful for

        .. class:: incremental

           + wrapping complexity for other programmers to use
           + i.e. a domain-specific language
           + generate classes/methods dynamically e.g. XML DTDs:

      ..

      + metaclasses do not (directly) affect instance's:

        .. class:: incremental

           + namespace lookup
           + method-resolution order
           + descriptor retrieval

Example #2: Define a Class from an SQL Table Definition
=======================================================

.. container:: slide-display

   .. class:: incremental

      | class Member(object):
      |     __metaclass__ = DatabaseTable
      |
      |     `dbtable = 'Members'  # a declaration`

      | class DatabaseTable(type):
      |
      |     `def __init__(cls, name, bases, class_dict):`
      |         `#from dbsetup import dbconn`
      |         `col_defs = dbconn.query_cols(table=class_dict['dbtable'])`
      |         `for col_def in col_defs:`
      |             `dbcolumn = wrap_col_rdwr(col_def) # a descriptor`
      |             `setattr(cls, col_def.name, dbcolumn)`

      + "process human-friendly decls into machine-friendly"

Example Problem #2 (cont'd)
===========================

.. container:: slide-display

   .. class:: incremental

      | def wrap_col_rdwr(col_def):
      |
      |     `def get_dbcol_value(self):`
      |         `return self.__dict__.get(col_def.name, None)`
      |
      |     `def set_dbcol_value(self, value):`
      |         `value = col_def.validate(value)`
      |         `self.__dict__[col_def.name] = value`
      |
      |     return property(get_dbcol_value, set_dbcol_value)

      + tag attrs with type/value constraints
      + check class for conformance to your requirements

        .. class:: incremental

           + must have docstring
           + spelling of method names
           + max inheritance depth
           + insure abstract methods of superclass are defined

Metaclasses versus Class Decorators
===================================

.. container:: slide-display

   .. class:: incremental

      + metaclasses?  class decorators?

        .. class:: incremental

           + the latter are much simpler
           + the latter can do almost everything the former can
           + only a metaclass can add methods to the class itself

           ..

           + class-level services (methods):

             .. class:: incremental

                + @classmethods provide them -to- instances
                + metaclass methods provide them to the class itself

      + ONLY a metaclass can add to class attrs not visible to *self*:

        1. meta-methods
        2. meta-properties

      + class decorators can be (more easily) stacked
      + class decorators are NOT inherited (metaclasses are)

About Meta-Inheritance
======================

.. container:: slide-display animation

   .. class:: incremental

      .. container:: handout

         |                                    |      class TagClass(type):
         | def TagClass(cls):                 |          def __init__(cls, name, bases, class_dict):
         |     cls.__special__ = True         |              cls.__special__ = True
         |     return cls

         | @TagClass
         | class Alpha(object):               |      class Alpha(object):
         |     pass                           |          __metaclass__ = TagClass

         | '__special__' in Alpha.__dict__    |      '__special__' in Alpha.__dict__
         | >>> True                           |      >>> True

         | class Beta(Alpha):                 |      class Beta(Alpha):
         |     pass                           |          pass

         | '__special__' in Beta.__dict__     |       '__special__' in Beta.__dict__
         | >>> False                          |        >>> False

      .. image:: graphics/mcd-defns.gif
      .. image:: graphics/mcd-use1.gif
      .. image:: graphics/mcd-use1-test.gif
      .. image:: graphics/mcd-use2.gif
      .. image:: graphics/mcd-use2-test.gif


Example #3: Log the Arguments/Return Value of Method Calls
==========================================================

.. container:: slide-display

   .. class:: incremental

      |  @tracecalls
      |  class Paragraph(object):
      |
      |      def lead_in(self, count, char='*'):
      |          return char * count

      |  >>> x = Paragraph()
      |  >>> x.lead_in(4)
      |  Called <bound method Paragraph.lead_in of <\__main__.Paragraph object at> 0xb7162c4c>> args=(4,), kw={} got '\*\*\*\*'
      |  '\*\*\*\*'

Example #3 (cont'd)
===================

.. container:: slide-display animation

   .. class:: incremental

      .. container:: handout

         | def CaptureCalls(orig_cls):
         |
         |     def my__getattribute__(self, name):
         |         attr = super(orig_cls, self).__getattribute__(name)
         |         return attr if not callable(attr) else CallWrapper(attr)
         |
         |     orig_cls.__getattribute__ = my__getattribute__
         |     return orig_cls

         | def CallWrapper(func):  # as a closure
         |
         |     def whencalled(*args, **kw):
         |         rc = func(*args, **kw)
         |         print "Called %s args=%r, kw=%r got %r" % (func, args, kw, rc)
         |         return rc
         |
         |    return whencalled

         | class CallWrapper(object):  # as a class
         |
         |     def __init__(self, func):
         |         self.func = func
         |
         |     def __call__(self, *args, **kw):
         |         rc = self.func(*args, **kw)
         |         print "Called %s args=%r, kw=%r got %r" % (self.func, args, kw, rc)
         |         return rc

      .. image:: graphics/tr-bare.gif
      .. image:: graphics/tr-getattr.gif
      .. image:: graphics/tr-super.gif
      .. image:: graphics/tr-callable.gif
      .. image:: graphics/tr-wrapper.gif
      .. image:: graphics/tr-cls-wrapper.gif

Lull After Metaclasses, Before Descriptors
==========================================

.. container:: slide-display center

   .. image:: graphics/after-metaclasses-breathing.jpg

   + (pause - take a deep breath...)

The Mechanism of Attribute Lookup
=================================

.. container:: slide-display

   .. class:: incremental

      | def __getattribute__(self, name):  # symbolic, not actual
      |
      |     `inst_v = self.__dict__.get(name, Missing)`
      |     `if inst_v is not Missing:`
      |         `return inst_v                               # return the instance attr value`
      |
      |     `cls_v = lookthrough__dict__s(self.__class__, name, Missing)`
      |     `if cls_v is not Missing:`
      |         `return cls_v                                # return the class attr value`
      |
      |     `meth = lookthrough__dict__s(self.__class__, '__getattr__', Missing)`
      |     `if meth is not Missing:`
      |         `return meth(name)`
      |
      |     raise AttributeError

When to Use Which Lookup Mechanism
==================================

.. container:: slide-display

   + if you want to see

   .. class:: incremental

      + every attribute lookup, override **__getattribute__**
      + many attribute lookups, add your own **__getattr__**

        .. class:: incremental

           + doesn't see all because only called as a last resort
           + therefore perfect for delegation

      + one attribute lookup, add a **descriptor**

      ..

      + __setattr__(self, name, value)  # to override storing value into self.__dict__
      + __delattr__(self, name)

Example 4: Overriding __getattr__
=================================

.. container:: slide-display

   .. class:: incremental

      + a wrapper around a bitmap element with a width and height
      + internally measured in pixels, but externally as inches

      | class Page(Bitmap):
      |
      |     def __getattr__(self, name):
      |         if name == 'width':  return self.__dict__['_width'] / 600 #dpi
      |         if name == 'height': return self.__dict__['_height'] / 600 #dpi
      |         raise AttributeError, name
      |
      |     def __setattr__(self, name, value):
      |         if name == 'width':  self.__dict__['_width'] = value * 600 #dpi
      |         if name == 'height': self.__dict__['_height'] = value * 600) #dpi
      |
      |     def __repr__(self):
      |         return "Page(%d x %d inches" % (self.width, self.height)

Example 4: Using a Descriptor
=============================

.. container:: slide-display

   .. class:: incremental

      | class Page(Bitmap):
      |
      |     `width = DimensionInches('width')   # a descriptor`
      |     `height = DimensionInches('height') # a descriptor`
      |
      |     def __repr__(self):
      |         return "Page(%d x %d inches)" % (self.width, self.height)

      | class DimensionInches(object):
      |     def __init__(self, attrname):
      |         self.attrname = attrname
      |     `def __get__(self, instance, owner):   # gives 'binding behavior'`
      |         `return instance.__dict__[self.attrname] / 600 #dpi`
      |     `def __set__(self, instance, value):`
      |         `instance.__dict__[self.attrname] = value * 600 #dpi`
      |     `def __delete__(self, instance):`
      |         `del instance.__dict__[self.attrname]`

The Mechanism of Attribute Lookup (descriptors)
===============================================

.. container:: slide-display

   .. class:: incremental

      | def __getattribute__(self, name):
      |     cls_v = lookthrough__dict__s(self.__class__, name, Missing)
      |
      |     `if hasattr(cls_v, '__get__') and hasattr(cls_v, '__set__'):`
      |        `return cls_v.__get__(self, self.__class__)   # invoke data descriptor`
      |
      |     inst_v = self.__dict__.get(name, Missing)
      |     if inst_v is not Missing:
      |         return inst_v                               # return the instance attr value
      |
      |     `if hasattr(cls_v, '__get__'):`
      |         `return cls_v.__get__(self, self.__class__)  # invoke non-data descriptor`
      |
      |     if cls_v is not Missing: return cls_v            # return the class attr value
      |     if hasattr(cls, '__getattr__'): return cls.__getattr__(name)
      |     raise AttributeError

What is a descriptor?
=====================

.. container:: slide-display

   .. class:: incremental

      + an object you place into the class attributes
      + a plug-in to the lookup mechanism
      + is shared by all instances, passed the 'instance' at each use

      ..

      + recognized by having a __get__ method, not by its class
      + does not know its name (hence reusable)
      + there is one per attribute to be overridden

      ..

      + may store its value in:

        .. class:: incremental

           + the instance __dict__ (perhaps a different name)
           + some other place
           + or just compute it as needed

Who uses descriptors?
=====================

.. container:: slide-display

   .. class:: incremental

      + argument currying (non-data descriptors; __get__ only)

      .. class:: monospaced

         + method objects:  self.display(a, b)   ==>  cls.display(self, a, b)
         + classmethods:    self.display(a, b)   ==>  cls.display(cls, a, b)
         + staticmethods:   self.display(a, b)   ==>  cls.display(a, b)

      + Python properties (data descriptors; __get__ and __set__)

        + attrname = property(fget, fset, fdel, doc)

      ..

      + recalculation after a setattr()

      ..

      + caching/lazy computation of a value

Caching an Attribute Value
==========================

.. container:: slide-display

   .. container:: sidebox boxed

      >>> p = Photo()
      >>> p.thumbnail    # computes thumbnail
      >>> p.thumbnail    # fetched from self.__dict__
      >>>
      >>> del p.__dict__['thumbnail']
      >>> p.thumbnail    # computes again
      >>> p.thumbnail    # already cached again

   .. class:: incremental

      | class ThumbnailBuilder(object):
      |
      |     def __init__(self, attrname, filename):
      |         self.attrname = attrname
      |         self.filename = filename
      |
      |     # non-data descriptor **behind** self.__dict__
      |     def __get__(self, instance, owner):
      |         with file(self.filename) as f:
      |             data = f.read()
      |             instance.__dict__[self.attrname] = data
      |             return data

      | class Photo(object):
      |     thumbnail = ThumbnailBuilder('thumbnail.gif')

Declare an Attribute Private to a Class
=======================================

.. container:: slide-display

   .. container:: sidebox boxed

      | def _ck_owner(self, obj):
      |
      |     caller_locals = sys._getframe(2).f_locals
      |
      |     if 'self' in caller_locals and caller_locals['self'] == obj:
      |         return
      |
      |     raise NameError("Attr %r of class %r is private." % (
      |         self.attrname, obj))

   .. class:: incremental

      | import sys
      |
      | class private(object):
      |
      |     def __init__(self, attrname):
      |         self.attrname = attrname
      |
      |     def __get__(self, obj, type=None):
      |         self._ck_owner(obj)
      |         return obj.__dict__[self.attrname]
      |
      |     def __set__(self, obj, value):
      |         self._ck_owner(obj)
      |         obj.__dict__[self.attrname] = value

For Unit Testing, Tracking Changes in a Value
=============================================

.. container:: slide-display

   .. container:: sidebox boxed

      >>> from parser import StateMachine
      >>> vt = ValueTracker(StateMachine, 'state')

      >>> main()

      >>> for h in vt.history:
      >>>     print h
      (0, 'target_trackstate.py', 6, '__init__')
      (1, 'target_trackstate.py', 9, 'advance')
      (2, 'target_trackstate.py', 9, 'advance')
      (3, 'target_trackstate.py', 9, 'advance')

   .. class:: incremental

      | import sys, import inspect
      | class ValueTracker(object):
      |
      |     def __init__(self, tgt_cls, attrname):
      |         self.attrname = attrname
      |         self.history = []
      |         setattr(tgt_cls, attrname, self)
      |
      |     def __get__(self, obj, type=None):
      |         return instance.__dict__[self.attrname]
      |
      |     def __set__(self, obj, value):
      |         instance.__dict__[self.attrname] = value
      |
      |         finfo = inspect.getframeinfo( sys._getframe(1) )
      |         self.history.append((value, finfo.filename,  finfo.lineno, finfo.function))

Questions?
==========

.. container:: slide-display center

   .. image:: graphics/questions-relaxation.jpg

   Metaprogramming is fun!

   .. class:: huge

      `Questions?`

Sample Code - A Randomizing Descriptor
======================================

.. container:: slide-display

   .. class:: incremental

      | import random
      |
      | class Die(object):
      |     def __init__(self, sides=6):
      |         self.sides = sides
      |
      |     def __get__(self, instance, owner):
      |         return int(random.random() * self.sides) + 1

      | class Game(object):
      |     strike = Die()        # random 6-sized die for odds of striking
      |     save = Die(sizes=10)  # random 10-sized die for odds of saving

For Debugging, Catching Writes to an Attribute
==============================================

.. container:: slide-display

   .. container:: sidebox boxed

      >>> Trouble.total = immutable('total')  # outside

      + any writes will give us a traceback to the culprit!

      >>> del Trouble.total

      + immutable trigger removed, instance value still there

   .. class:: incremental

      | class immutable(object):
      |
      |     def __init__(self, attrname):
      |         self.attrname = attrname
      |
      |     def __get__(self, instance, owner):
      |         return instance.__dict__[self.attrname]
      |
      |     # data descriptor **in-front-of** self.__dict__
      |     def __set__(self, instance, value):
      |         raise AttributeError, "Writing to immutable %s" % self.attrname

      | class Trouble(object):
      |
      |     def compute(self):
      |         self.total = (a.bal for a in ledger)

A Few More Ideas for Metaprogramming
====================================

.. container:: slide-display

   .. class:: incremental

      ::

        @trackexceptions
        def func(...):

        @trackexceptions(methpatt="get_")
        class C(...):

      ::

        @trackinstances
        class C(...):

      ::

        @internalmethod
        def greetings(self, x):

      + detect the most number of threads running concurrently
      + log all calls from module X to function Y

      ::

        @addtoclass(Moonbase)  # at import time
        def hello(self, code, priormeth=None):
          print "Hello"
          self.greeting(68)







Sample Code - Binding of Functions into Methods
===============================================

.. container:: slide-display

Class __dict__ store methods as functions.

Python is built upon a function-based environment.  Non-data descriptors add
the object-oriented features by binding functions into methods.

   .. class:: incremental

      | class MethodDescriptor(object):
      |     def __get__(self, instance, instance_type=None):
      |         return types.MethodType(self, instance, instance_type)

      | class D(object):
      |     def func(self, x):
      |         return x

      >>> D.__dict__['f']
      <function func at 0xb73ebf7c>

      >>> D.f                 # type(D).__dict__['func'].__get__(None, self)
      <unbound method D.func>

      >>> d = D()
      >>> d.f                 # type(d).__dict__['f'].__get__(d, type(d))
      <bound method D.func of <__main__.D object at 0xb71c794c>>




  Monitor Who is Opening Which Files

  .. container:: slide-display

     .. class:: incremental







  A Solution to #8: ??? external decorating __builtin__

  .. container:: slide-display

     .. class:: incremental

        + can filter on path, name, caller
        + can hook the .close method of a specific instance???

        + applying function decorators from outside
        + applying class decorators from outside

        + more descriptors; using get-overrides to catch file opens, in order to understand a complex pgm
          but maybe just for opens of files in a specific directory or a particular name

          + (talk about fstozodb.log or fax/ directory that keeps popping up; show traceback)
          + (talk about *changing* the name or directory of a file being opened)


No More
=======


::

  What are Some Examples of Metaprogramming?

   + protocol negotiation
   + ORMs ala SQLAlchemyDA

  consider - how can I walk across the attrs of a class?  an instance?


  as a demo, create a class equivalent to a function, with default args.

  def func(...):

  class C(...):
    def meth(...):


  for (1) debugging or (2) changing code you do not own/control


  Callability: Benefits of Decorators

  .. container:: slide-display

     .. class:: incremental

  username = mkfunction(globalspace, formalparameters, codeobject)
  username = export(username)  # must return a callable
  ... (major separation in time)   a decorator is NOT the wrapper; a decorator DOES the wrapping
              i.e. the gift wrapper clerk and the wrapping paper itself
  username('Jeff')




  metaprogramming
    how do we get our metapgm wrapped around another pgm?
    - run 2nd as arg to 1st?
    - change site.py
    - use -m <module>?


    5) sliding a delegate in
       (replace a method that takes a self, with a delegate that has its own self)
       (and maybe a closure arg of the prior method that was replaced)


    patching functions
  - in the class space
  - in the instance space

  use Ctrl-C trick to drop into a running pgm
  - and import a metapgm that logs only the IP addr of a problem browser



  1) subclassing can be treated as a registration
  of an object with the parent class, and the body of the cubslclass being the
  particular registration data.  Think media handlers.


   ? can I subclass a module
   ? can I make a module's dict read-only?


  >>> int.__subclasses__()
  [<type 'bool'>]



  AOP?
  delegation?
  likeness to plugboard logic analyzer


  Looking Behind the Walls (the secret passages)
  In Python's Attic
  In Python's Basement

  ?? reasons for swapping out class methods at runtime??



  mix-in classes are a way to produce a class from fragments of a class
   - awkward, multiple-inheritance
   - hard to pickle



  what does this do?   python -m mymod helper.py


  even with multiple inheritance, an instance knows of its one true __class__

  __metaclass__ does not have to be a class, just a callable taking (name, bases, dict)
      metaclass(name, bases, dict)  ===>  metaclass.__class__.__call__(name, bases, dict)
                        invokes metaclass.__new__  and  metaclass.__init__

      + final classes are a form of definition constraint
        find all classes using object.__subclasses__()
      + defer such checking to unit tests?  something at import time

      + someone declares their class wraps an SQL table; introspect the columns of
        that table and provide descriptors for each one, including type contraints.

      + class/instance  ::  table/row     a shared context
        a useful example of class methods and instance methods i.e. Members
          nrecs = len(Members)
          m = Members.load(...)
          m = Members(...)
          m.save()

      + about __subclasses__(); use to tell a metaclass to flush each caching class?
      + at unittest time, tell metaclasses to verify each of their classes
      + how to walk all classes in a program, in order to validate things about them
      + can I find all nested classes?  are they missing a __module__ or __file__?

      + metaclasses let you share code among multiple meta*classes*.  Treats classes
        more like objects -- they come and go, are duplicated, collected, iterated
        over.  A custom class appears for each domain object found.

        Good for modeling systems with class-like behavior?

        Domain objects show up in pgms as classes and instances.


  object.__getattribute__(name)
    b.x
    type(b).__dict__['x'].__get__(b, type(b))

  data descriptors
  instance variables
  non-data descriptors
  __getattr__

  type.__getattribute__(name)
    B.x
    B.__dict__['x'].__get__(None, B)

    def __getattribute__(self, key):
      "Emulate type_getattro() in Objects/typeobject.c"
      v = object.__getattribute__(self, key)
      if hasattr(v, '__get__'):
         return v.__get__(None, self)
      return v

   + descriptors are invoked by the __getattribute__ method (override it and they break)


  a.x
  a.__dict__['x'
  type(a).__dict__['x'
  (then base classes)

  direct call:       a.x =>                      x.__get__(a)
  instance binding:  a.x =>  type(a).__dict__['x'].__get__(a, type(a))
    (has a precendence)
    if no __get__, return the descriptor object itself, unless there is a value in the __dict__
    if has __set__ and/or __delete__, then it is a data descriptor
    if has neither __set__ nor __delete__, then it is a non-data descriptor
      hence data descriptors override a redefinition in the instance
      and non-data descriptors can be overridden by instances


  class binding:     A.x =>        A.__dict__['x'].__get__(None, A)

  object.__getattribute__(self, name)  # ALWAYS CALLED  (MAY BE BYPASSED BY IMPLICIT

    "Special Method Lookup"   (for performance reasons)
        len(x)  <==> type(x).__len__(x)   # looks up via metaclass __getattribute__
        x.__len__()                       # looks up via class __getattribute__
        len(x)                            # bypasses __getattribute__ and uses __len__ method defined in the class
              (none of these ever look in the instance __dict__)


  object.__getattr__(self, name)   # called when name has not been found in the usual places

  object.__setattr__(self, name, value)  # called instead of storing value into __dict__

  object.__delattr__(self, name)


  (show 'binding behavior', i.e. a value stored WITHOUT __get__/__set__ and a value stored WITH them)


      + except when it finds an object with a __get__/__set__

  object.__get__(self, instance, owner)  # return value or AttributeError
  object.__set__(self, instance, value)
  object.__delete__(self, instance)

      + neither 'type' nor 'object have a '__getattr__' method.

  type
  (__dict__/(dictproxy)
    __call__                                  'type'  slot_tp_call?    x(...)  <==>  x.__call__(...)
       lookup_method(self, '__call__') ==> _PyType_Lookup(mytype, attrname)
    __delattr__               OBJECT?         'object'
    __eq__                                    'type'
    __ge__                                    'object'
    __getattribute__          OBJECT?         'type'                   x.name  <==>  x.__getattribute__(name)

           NAME                SLOT         FUNCTION              WRAPPER          DOC
    TPSLOT("__getattribute__", tp_getattro, slot_tp_getattr_hook, wrap_binaryfunc, ""),
    TPSLOT("__getattribute__", tp_getattr,  NULL,                 NULL,            ""),
      slot_tp_getattro       used when __getattribute__ is overridden but no    __getattr__ is present
      slot_tp_getattr_hook   used when a __getattr__ hook is present

    __gt__                                    'object'
    __hash__                  OBJECT?         'type'
    __init__                  OBJECT?         'type'
    __le__                                    'object'
    __lt__                                    'object'
    __ne__                                    'type'
    __new__                   OBJECT?         'type'
    __repr__                  OBJECT?         'type'
    __setattr__               OBJECT?         'type'
  (members)
    __base__
    __basicsize__
    __dictoffset__
    __flags__
    __itemsize__
    __mro__
    __weakrefoffset__
  (getsets)
    __abstractmethods__ (R/W)
    __bases__           (R/W)
    __dict__            (R/O)
    __doc__             (R/O)
    __module__          (R/W)
    __name__            (R/W)
  (methods)
    __instancecheck__
    __subclasscheck__
    __subclasses__
    mro

  (interesting)
    tp_call ::= type_call()
      obj = type->tp_new(type, args, kwds)
      type->tp_init(obj, args, kwds)
      return obj

  tp_getattro ::= type_getattro(type, name)
    metatype = Py_TYPE(type)

    meta_attribute = _PyType_Lookup(metatype, name)         # look in the metatype
    if meta_attribute:
      meta_get = Py_TYPE(meta_attribute)->tp_descr_get
      if meta_get and PyDescr_IsData(meta_attribute):       # use data desc in metatype
          return meta_get(meta_attribute, type, metatype)

    attribute = _PyType_Lookup(type, name)                  # look in tp_dict of this type *and* bases
    if attribute:
      local_get = Py_TYPE(attribute)->tp_desc_get
      if local_get:
          return local_get(attribute, NULL, type)
      return attribute

    if meta_get:                                            # use non-data desc in metatype
      return meta_get(meta_attribute, type, metatype)

    if meta_attribute:
      return meta_attribute

    raise AttributeError

  tp_setattro ::= type_setattro()
  tp_new ::= type_new()
  tp_init ::= type_init()

  object_new()
  object_init()


  call_method()
  call_maybe()
  PyObject_CallMethod()
  _PyType_Lookup(type, '__dict__')
  lookup_maybe()
  lookup_method()
  _PyObject_LookupSpecial()


  Does a 'type' have its own internal dictionary?  Really?


  type.__base__  ---> object
  type           <--- object.__class__
  None           <--- object.__base__
  type.__class__ ---> type


  object
    (__dict__)
      __delattr__                             'object'
      __doc__
      __getattribute__                        'object'
      __hash__                                'object'
      __init__                                'object'
      __new__                                 'type'
      __repr__                                'object'
      __setattr__                             'object'
      __str__                                 'object'
    (getsets)
      __class__       (R/W)
    (methods)
      __format__
      __reduce__
      __reduce_ex__
      __sizeof__
      __subclasshook__
    (members)
      EMPTY

  tp_getattro ::= PyObject_GenericGetAttr
  tp_setattro ::= PyObject_GenericSetAttr
  tp_new      ::= object_new(type, args, kwds)
  tp_init     ::= object_init # NOP


  PyObject_GetAttrString(obj, name)
    if Py_TYPE(obj)->tp_getattr:
        return Py_TYPE(obj)->tp_getattr(obj, name)
    return PyObject_GetAttr(obj, name)

  PyObject_GetAttr(obj, name)
    tp = Py_TYPE(obj)
    if tp->tp_getattro:
        return tp->tp_getattro(obj, name)
    if tp->tp_GETATTR:
        return tp->tp_getattr(obj, name)
    raise AttributeError


  Descriptor Machinery for Classes
  --------------------------------

  Implemented in *type.__getattribute__*

  Example: A.x

  ::

    descriptor = A.__class__.x
    descriptor.__get__(instance=None, instance_type=self)

    def __getattribute__(self, key):
      v = object.__getattribute__(self, key)
      if hasattr(v, '__get__'):
        return v.__get__(None, self)
      return v

  Descriptor Machinery for Instances
  ----------------------------------

  Implemented in *object.__getattribute__*

  Example: a.x

  ::

    descriptor = a.__class__.x
    descriptor.__get__(instance=a, instance_type=type(a))


  How Do Decorators Work?  the 3-things a decorator can do

  .. container:: slide-display

     .. class:: incremental

        + registering *username* with some entity::

           def export(func):
               api_register(func)
               return func

        + tagging *username* with additional metadata::

           def export(func):
               func.__export__ = True
               return func

        + inserting code between the caller and callee::

           def export(func):
               def trace(*args, **kw):
                   rc = func(*args, **kw)
                   print args, kw, rc
                   return rc
               return trace

  Sample Problem #9: ??? tracing the cause of a slowdown

  .. container:: slide-display

     .. class:: incremental

        + in-out phase checking

          + (use it to measure time for a call)
          + (use it to toggle logging on/off)

  A Solution to #9: hooking the operation, measuring the time and saving the log -if- the problem showed up

  .. container:: slide-display

     .. class:: incremental

        + ???

        + can filter on details of events, not just the overall event
          + import of a specific module
          + call to a function -from- a specific module
          + make attrs read-only or invisible outside their creator
          + record their performance

       + catch file opens, in a specific directory
       + toggle logging on/off only within a specific section of code or when something looks wrong


      + special methods: __XXX__ bypass descriptors, for performance, avoid recursion
      + there are two kinds of descriptors; data and non-data
        + non-data: methods, staticmethod, classmethod
        + data: property
      + to make a data descriptor read-only
        + define both __get__ and __set_
        + have __set__ raise an AttributeError
      + neither 'type' nor 'object have a '__getattr__' method.

      + implementor of descriptor behavior for
        + classes, type.__getattribute__
        + instances, object.__getattribute__

  Use of Descriptors in property() builtin
  ----------------------------------------

  ::

    class MyClass(object):
      def x(self):
        def get(self):
          return self.__x
        def set(self, value):
          self.__x = value
        def del(self):
          del self.__x
      x = property(x.get, x.set, x.del, "'x' property")

  Example 4 - Implementation of *property*
  ----------------------------------------

  ::

    class Property(object):
      def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        self.__doc__ = doc

      def __get__(self, instance, instance_type=None):
        if instance is None:
          return self
        if self.fget is None:
          raise AttributeError, "unreadable attribute"
        return self.fget(instance)

  (continued)

  Example 4 - cont'd
  ------------------

   ::

      def __set__(self, instance, value):
        if self.fset is None:
          raise AttributeError, "can't set attribute"
        self.fset(instance, value)

      def __delete__(self, instance):
        if self.fdel is None:
          raise AttributeError, "can't delete attribute"
        self.fdel(instance)


Example 5 - Implementation of StaticMethod builtin
--------------------------------------------------

Lack any reference to the class or instance.

::

  class StaticMethod(object):
    def __init__(self, f):
      self.f = f

    def __get__(self, instance, instance_type=None):
      return self.f

Example 6 - Implementation of ClassMethod builtin
-------------------------------------------------

Lack any reference to the instance *but* has one to the class.

Useful for alternate class constructors, such as Dict.fromkeys().

::

  class ClassMethod(object):
    def __init__(self, f):
      self.f = f

    def __get__(self, instance, instance_type=None):
      if instance_type is None:
         instance_type = type(instance)

      def newfunc(*args):
         return self.f(instance_type, *args)
      return newfunc


  Summary: Benefits of Metaprogramming

  .. container:: slide-display

     .. class:: incremental

       + adopt a more declarative style

          + less programmer work, less human error
          + hiding necessary magic

        + adapt to negotiated protocols
        + better control of unchangable legacy programs

        + track down difficult runtime problems

          + protect readonly, private attributes
          + capture changes-in-state
          + limit the logging needed (just-in-time)

        + test your knowledge of a complex system

          + what modules or files are used?
          + probe for expensive operations

        + try out experimental changes

          + new caching algorithms

  Summary: Drawbacks of Metaprogramming

  .. container:: slide-display

     .. class:: incremental

        + influences not visible in code, hard to understand
        + requires a different perspective on programming
        + can interfere with pgm performance, correctness


..
   XXLocal Variables:
   mode: rst
   mode: outline-minor
   End:
